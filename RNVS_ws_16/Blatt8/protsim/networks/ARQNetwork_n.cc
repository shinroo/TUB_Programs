//-----------------------------------------
//
// Generated by nedtool, version 3.3
// date: Thu Jul  2 22:42:52 2009
//
//-----------------------------------------


#include <math.h>
#include "omnetpp.h"

// NEDC version check
#define NEDC_VERSION 0x0303
#if (NEDC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of nedc: 'make clean' should help.
#endif

// Disable warnings about unused variables. For MSVC and BC only:
// GCC has no way to turn on its -Wunused option in a source file :(
#ifdef _MSC_VER
#  pragma warning(disable:4101)
#endif
#ifdef __BORLANDC__
#  pragma warn -waus
#  pragma warn -wuse
#endif

static cModuleType *_getModuleType(const char *modname)
{
    cModuleType *modtype = findModuleType(modname);
    if (!modtype)
        throw new cRuntimeError("Module type definition %s not found (Define_Module() missing from C++ code?)", modname);
    return modtype;
}

static void _checkModuleVectorSize(int vectorsize, const char *mod)
{
    if (vectorsize<0)
        throw new cRuntimeError("Negative module vector size %s[%d]", mod, vectorsize);
}

static void _readModuleParameters(cModule *mod)
{
    int n = mod->params();
    for (int k=0; k<n; k++)
        if (mod->par(k).isInput())
            mod->par(k).read();
}

static int _checkModuleIndex(int index, int vectorsize, const char *modname)
{
    if (index<0 || index>=vectorsize)
        throw new cRuntimeError("Submodule index %s[%d] out of range, sizeof(%s) is %d", modname, index, modname, vectorsize);
    return index;
}

static cGate *_checkGate(cModule *mod, const char *gatename)
{
    cGate *g = mod->gate(gatename);
    if (!g)
        throw new cRuntimeError("%s has no gate named %s",mod->fullPath().c_str(), gatename);
    return g;
}

static cGate *_checkGate(cModule *mod, const char *gatename, int gateindex)
{
    cGate *g = mod->gate(gatename, gateindex);
    if (!g)
        throw new cRuntimeError("%s has no gate %s[%d]",mod->fullPath().c_str(), gatename, gateindex);
    return g;
}

static cGate *_getFirstUnusedParentModGate(cModule *mod, const char *gatename)
{
    int baseId = mod->findGate(gatename);
    if (baseId<0)
        throw new cRuntimeError("%s has no %s[] gate",mod->fullPath().c_str(), gatename);
    int n = mod->gate(baseId)->size();
    for (int i=0; i<n; i++)
        if (!mod->gate(baseId+i)->isConnectedInside())
            return mod->gate(baseId+i);
    throw new cRuntimeError("%s[] gates are all connected, no gate left for `++' operator",mod->fullPath().c_str(), gatename);
}

static cGate *_getFirstUnusedSubmodGate(cModule *mod, const char *gatename)
{
    int baseId = mod->findGate(gatename);
    if (baseId<0)
        throw new cRuntimeError("%s has no %s[] gate",mod->fullPath().c_str(), gatename);
    int n = mod->gate(baseId)->size();
    for (int i=0; i<n; i++)
        if (!mod->gate(baseId+i)->isConnectedOutside())
            return mod->gate(baseId+i);
    int newBaseId = mod->setGateSize(gatename,n+1);
    return mod->gate(newBaseId+n);
}

static cFunctionType *_getFunction(const char *funcname, int argcount)
{
    cFunctionType *functype = findFunction(funcname,argcount);
    if (!functype)
        throw new cRuntimeError("Function %s with %d args not found", funcname, argcount);
    return functype;
}

static cChannel *_createChannel(const char *channeltypename)
{
    cChannelType *channeltype = findChannelType(channeltypename);
    if (!channeltype)
        throw new cRuntimeError("Channel type %s not found", channeltypename);
    cChannel *channel = channeltype->create("channel");
    return channel;
}

static cChannel *_createNonTypedBasicChannel(double delay, double error, double datarate)
{
    cBasicChannel *channel = new cBasicChannel("channel");
    if (delay!=0) channel->setDelay(delay);
    if (error!=0) channel->setError(error);
    if (datarate!=0) channel->setDatarate(datarate);
    return channel;
}

static cXMLElement *_getXMLDocument(const char *fname, const char *pathexpr=NULL)
{
    cXMLElement *node = ev.getXMLDocument(fname, pathexpr);
    if (!node)
        throw new cRuntimeError(!pathexpr ? "xmldoc(\"%s\"): element not found" : "xmldoc(\"%s\", \"%s\"): element not found",fname,pathexpr);
    return node;
}

ModuleInterface(ARQNetworkModule)
    // parameters:
    Parameter(routing, ParType_String)
    Parameter(maxTTL, ParType_Numeric)
    Parameter(N, ParType_Numeric)
    Parameter(localDelay, ParType_Numeric)
    Parameter(localDatarate, ParType_Numeric)
    Parameter(localError, ParType_Numeric)
    Parameter(wideAreaDelay, ParType_Numeric)
    Parameter(wideAreaDatarate, ParType_Numeric)
    Parameter(wideAreaError, ParType_Numeric)
    Parameter(leftNodeAddrOffset, ParType_Numeric)
    Parameter(rightNodeAddrOffset, ParType_Numeric)
EndInterface

Register_ModuleInterface(ARQNetworkModule);

class ARQNetworkModule : public cCompoundModule
{
  public:
    ARQNetworkModule() : cCompoundModule() {}
  protected:
    virtual void doBuildInside();
};

Define_Module(ARQNetworkModule);

namespace {  // unnamed namespace to avoid name clashes

// evaluator for expression at ARQNetwork.ned:34
class Expr0 : public cDoubleExpression
{
  private:
    cModule *mod;
    double leftNodeAddrOffset22;
    long index23;
  public:
    Expr0(cModule *mod, double leftNodeAddrOffset22, long index23)  {
        this->mod=mod;
        this->leftNodeAddrOffset22=leftNodeAddrOffset22;
        this->index23=index23;
    }
    cExpression *dup()  {return new Expr0(mod, leftNodeAddrOffset22, index23);}
    double evaluate()  {return (double)(leftNodeAddrOffset22)+(double)(index23);}
};

// evaluator for expression at ARQNetwork.ned:78
class Expr1 : public cDoubleExpression
{
  private:
    cModule *mod;
    double rightNodeAddrOffset118;
    long index119;
  public:
    Expr1(cModule *mod, double rightNodeAddrOffset118, long index119)  {
        this->mod=mod;
        this->rightNodeAddrOffset118=rightNodeAddrOffset118;
        this->index119=index119;
    }
    cExpression *dup()  {return new Expr1(mod, rightNodeAddrOffset118, index119);}
    double evaluate()  {return (double)(rightNodeAddrOffset118)+(double)(index119);}
};

}  // end unnamed namespace

void ARQNetworkModule::doBuildInside()
{
    cModule *mod = this;

    // temporary variables:
    cPar tmpval;
    const char *modtypename;

    mod->setBackgroundDisplayString("p=-126,2;b=706,530");

    // submodules:
    cModuleType *modtype = NULL;
    int submodindex;

    //
    // submodule 'LeftNode':
    //
    int LeftNode_size = (int)(mod->par("N"));
    _checkModuleVectorSize(LeftNode_size,"LeftNode");
    cModule **LeftNode_p = new cModule *[LeftNode_size];
    if (LeftNode_size>0)
    {
        modtype = _getModuleType("NetworkNode");
    }
    for (submodindex=0; submodindex<LeftNode_size; submodindex++)
    {
        LeftNode_p[submodindex] = modtype->create("LeftNode", mod, LeftNode_size, submodindex);
        cContextSwitcher __ctx(LeftNode_p[submodindex]); // do the rest in this module's context

        // parameter assignments:
        LeftNode_p[submodindex]->par("nodeAddr") = tmpval.setDoubleValue(new Expr0(mod, mod->par("leftNodeAddrOffset"), submodindex));
        LeftNode_p[submodindex]->par("applicationType0") = mod->par("routing");
        LeftNode_p[submodindex]->par("applicationType1") = "DummyApplication";
        LeftNode_p[submodindex]->par("applicationType2") = "DummyApplication";
        LeftNode_p[submodindex]->par("applicationType3") = "DummyApplication";
        LeftNode_p[submodindex]->par("applicationType4") = "DummyApplication";

        // gatesizes:
        LeftNode_p[submodindex]->setGateSize("netIn", (int)(1));
        LeftNode_p[submodindex]->setGateSize("netOut", (int)(1));

        _readModuleParameters(LeftNode_p[submodindex]);
        LeftNode_p[submodindex]->setDisplayString("p=60,60,column;b=40,24");
    }

    //
    // submodule 'LeftRouter':
    //
    int LeftRouter_size = 1;
    modtype = _getModuleType("NetworkNode");
    cModule *LeftRouter_p = modtype->create("LeftRouter", mod);
    {
        cContextSwitcher __ctx(LeftRouter_p); // do the rest in this module's context

        // parameter assignments:
        LeftRouter_p->par("nodeAddr") = 1000;
        LeftRouter_p->par("applicationType0") = mod->par("routing");
        LeftRouter_p->par("applicationType1") = "DummyApplication";
        LeftRouter_p->par("applicationType2") = "DummyApplication";
        LeftRouter_p->par("applicationType3") = "DummyApplication";
        LeftRouter_p->par("applicationType4") = "DummyApplication";

        // gatesizes:
        LeftRouter_p->setGateSize("netIn", (int)((double)(mod->par("N"))+(double)(1)));
        LeftRouter_p->setGateSize("netOut", (int)((double)(mod->par("N"))+(double)(1)));

        _readModuleParameters(LeftRouter_p);
        LeftRouter_p->setDisplayString("p=200,260;b=40,24");
    }

    //
    // submodule 'RightRouter':
    //
    int RightRouter_size = 1;
    modtype = _getModuleType("NetworkNode");
    cModule *RightRouter_p = modtype->create("RightRouter", mod);
    {
        cContextSwitcher __ctx(RightRouter_p); // do the rest in this module's context

        // parameter assignments:
        RightRouter_p->par("nodeAddr") = 2000;
        RightRouter_p->par("applicationType0") = mod->par("routing");
        RightRouter_p->par("applicationType1") = "DummyApplication";
        RightRouter_p->par("applicationType2") = "DummyApplication";
        RightRouter_p->par("applicationType3") = "DummyApplication";
        RightRouter_p->par("applicationType4") = "DummyApplication";

        // gatesizes:
        RightRouter_p->setGateSize("netIn", (int)((double)(mod->par("N"))+(double)(1)));
        RightRouter_p->setGateSize("netOut", (int)((double)(mod->par("N"))+(double)(1)));

        _readModuleParameters(RightRouter_p);
        RightRouter_p->setDisplayString("p=360,260;b=40,24");
    }

    //
    // submodule 'RightNode':
    //
    int RightNode_size = (int)(mod->par("N"));
    _checkModuleVectorSize(RightNode_size,"RightNode");
    cModule **RightNode_p = new cModule *[RightNode_size];
    if (RightNode_size>0)
    {
        modtype = _getModuleType("NetworkNode");
    }
    for (submodindex=0; submodindex<RightNode_size; submodindex++)
    {
        RightNode_p[submodindex] = modtype->create("RightNode", mod, RightNode_size, submodindex);
        cContextSwitcher __ctx(RightNode_p[submodindex]); // do the rest in this module's context

        // parameter assignments:
        RightNode_p[submodindex]->par("nodeAddr") = tmpval.setDoubleValue(new Expr1(mod, mod->par("rightNodeAddrOffset"), submodindex));
        RightNode_p[submodindex]->par("applicationType0") = mod->par("routing");
        RightNode_p[submodindex]->par("applicationType1") = "DummyApplication";
        RightNode_p[submodindex]->par("applicationType2") = "DummyApplication";
        RightNode_p[submodindex]->par("applicationType3") = "DummyApplication";
        RightNode_p[submodindex]->par("applicationType4") = "DummyApplication";

        // gatesizes:
        RightNode_p[submodindex]->setGateSize("netIn", (int)(1));
        RightNode_p[submodindex]->setGateSize("netOut", (int)(1));

        _readModuleParameters(RightNode_p[submodindex]);
        RightNode_p[submodindex]->setDisplayString("p=540,60,column;b=40,24");
    }

    //
    // connections:
    //
    cGate *srcgate, *destgate;

    cChannel *channel;
    cPar *par;
    // for loop:
    {
        long start = (long)(1);
        long end = (long)(mod->par("N"));
        for (long i_var=start; i_var<=end; i_var++)
        {
            // connection
            srcgate = _checkGate(LeftNode_p[_checkModuleIndex((int)((double)(i_var)-(double)(1)),LeftNode_size,"LeftNode")], "netOut", (int)(0));
            destgate = _checkGate(LeftRouter_p, "netIn", (int)(i_var));

            // add channel
            channel = new cBasicChannel("channel");
            par = new cPar("delay");
            (*par) = mod->par("localDelay")            ;
            channel->addPar(par);
            par = new cPar("datarate");
            (*par) = mod->par("localDatarate")            ;
            channel->addPar(par);
            par = new cPar("error");
            (*par) = mod->par("localError")            ;
            channel->addPar(par);
            srcgate->connectTo(destgate,channel);

            // connection
            srcgate = _checkGate(LeftRouter_p, "netOut", (int)(i_var));
            destgate = _checkGate(LeftNode_p[_checkModuleIndex((int)((double)(i_var)-(double)(1)),LeftNode_size,"LeftNode")], "netIn", (int)(0));

            // add channel
            channel = new cBasicChannel("channel");
            par = new cPar("delay");
            (*par) = mod->par("localDelay")            ;
            channel->addPar(par);
            par = new cPar("datarate");
            (*par) = mod->par("localDatarate")            ;
            channel->addPar(par);
            par = new cPar("error");
            (*par) = mod->par("localError")            ;
            channel->addPar(par);
            srcgate->connectTo(destgate,channel);

            // connection
            srcgate = _checkGate(RightNode_p[_checkModuleIndex((int)((double)(i_var)-(double)(1)),RightNode_size,"RightNode")], "netOut", (int)(0));
            destgate = _checkGate(RightRouter_p, "netIn", (int)(i_var));

            // add channel
            channel = new cBasicChannel("channel");
            par = new cPar("delay");
            (*par) = mod->par("localDelay")            ;
            channel->addPar(par);
            par = new cPar("datarate");
            (*par) = mod->par("localDatarate")            ;
            channel->addPar(par);
            par = new cPar("error");
            (*par) = mod->par("localError")            ;
            channel->addPar(par);
            srcgate->connectTo(destgate,channel);

            // connection
            srcgate = _checkGate(RightRouter_p, "netOut", (int)(i_var));
            destgate = _checkGate(RightNode_p[_checkModuleIndex((int)((double)(i_var)-(double)(1)),RightNode_size,"RightNode")], "netIn", (int)(0));

            // add channel
            channel = new cBasicChannel("channel");
            par = new cPar("delay");
            (*par) = mod->par("localDelay")            ;
            channel->addPar(par);
            par = new cPar("datarate");
            (*par) = mod->par("localDatarate")            ;
            channel->addPar(par);
            par = new cPar("error");
            (*par) = mod->par("localError")            ;
            channel->addPar(par);
            srcgate->connectTo(destgate,channel);

        }
    }
    // connection
    srcgate = _checkGate(LeftRouter_p, "netOut", (int)(0));
    destgate = _checkGate(RightRouter_p, "netIn", (int)(0));

    // add channel
    channel = new cBasicChannel("channel");
    par = new cPar("delay");
    (*par) = mod->par("wideAreaDelay")    ;
    channel->addPar(par);
    par = new cPar("datarate");
    (*par) = mod->par("wideAreaDatarate")    ;
    channel->addPar(par);
    par = new cPar("error");
    (*par) = mod->par("wideAreaError")    ;
    channel->addPar(par);
    srcgate->connectTo(destgate,channel);

    // connection
    srcgate = _checkGate(RightRouter_p, "netOut", (int)(0));
    destgate = _checkGate(LeftRouter_p, "netIn", (int)(0));

    // add channel
    channel = new cBasicChannel("channel");
    par = new cPar("delay");
    (*par) = mod->par("wideAreaDelay")    ;
    channel->addPar(par);
    par = new cPar("datarate");
    (*par) = mod->par("wideAreaDatarate")    ;
    channel->addPar(par);
    par = new cPar("error");
    (*par) = mod->par("wideAreaError")    ;
    channel->addPar(par);
    srcgate->connectTo(destgate,channel);

    // check all gates are connected:
    mod->checkInternalConnections();


    //
    // this level is done -- recursively build submodules too
    //
    for (submodindex=0; submodindex<LeftNode_size; submodindex++)
        LeftNode_p[submodindex]->buildInside();
    delete [] LeftNode_p;
    LeftRouter_p->buildInside();
    RightRouter_p->buildInside();
    for (submodindex=0; submodindex<RightNode_size; submodindex++)
        RightNode_p[submodindex]->buildInside();
    delete [] RightNode_p;
}

class ARQNetwork : public cNetworkType
{
  public:
    ARQNetwork(const char *name) : cNetworkType(name) {}
    ARQNetwork(const ARQNetwork& n) : cNetworkType(n.name()) {operator=(n);}
    virtual void setupNetwork();
};

Define_Network(ARQNetwork);

void ARQNetwork::setupNetwork()
{
    // temporary variables:
    cPar tmpval;
    const char *modtypename;

    cModuleType *modtype;

    modtype = _getModuleType("ARQNetworkModule");
    cModule *ARQNetwork_p = modtype->create("ARQNetwork", NULL);

    cContextSwitcher __ctx(ARQNetwork_p); // do the rest in this module's context
    // parameter assignments:
    ARQNetwork_p->par("maxTTL") = 16;

    _readModuleParameters(ARQNetwork_p);
    // build submodules recursively (if it has any):
    ARQNetwork_p->buildInside();
}

